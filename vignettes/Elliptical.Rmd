---
title: "Elliptical Copula → TrialSimulator: End-to-End Example (Gaussian)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Elliptical Copula to TrialSimulator (Gaussian)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE
)
```

```{r, echo = FALSE, results = "asis"}
cat(
  "<style>\n",
  "pre.sourceCode { background-color: #f7f7f7; }\n",
  "pre > code.sourceCode > span { display: block; }\n",
  "</style>\n",
  sep = ""
)
```

This vignette demonstrates how to wrap the `simdatacopulas` (elliptical-family copulas) joint generator—"controllable dependence + arbitrary marginals"—into the `generator(n)` interface required by `TrialSimulator`, and how to:

1. Define endpoints / arms / trial
2. Set milestones and run
3. Read locked data and run basic checks

## 1. Load Dependencies

```{r}
library(simdata)
library(simdatacopulas)
library(TrialSimulator)
```

## 2. Build a Joint Generator with a Gaussian Copula (Elliptical Family)

Core idea:

1. The copula generates dependent \(U \in (0,1)^d\)
2. The marginal quantile function `dist[[j]](u)` maps each column \(U_j\) to the target variable scale

This example uses a 4-dimensional dependence structure (`structure = "un"`):

- `PFS_raw`: raw PFS time-to-event (positive)
- `OS_extra`: additional survival time after PFS (positive)
- `BIOM_latent`: continuous biomarker
- `ORR_latent`: latent normal variable, later thresholded into binary ORR

### 2.1 Correlation Matrix (unstructured)

```{r}
Sigma <- matrix(c(
  1.0,  0.6,  0.4,  0.3,
  0.6,  1.0,  0.5,  0.4,
  0.4,  0.5,  1.0,  0.7,
  0.3,  0.4,  0.7,  1.0
), nrow = 4, byrow = TRUE)
Sigma
```

### 2.2 Marginals for placebo and treatment

Both groups use the same copula dependence structure `Sigma`, but different marginal parameters to represent a "treatment effect":

- Longer PFS/OS under treatment
- Higher ORR under treatment
- Lower BIOM mean under treatment (illustrative only)

```{r}
dist_pbo <- list(
  function(u) stats::qlnorm(u, meanlog = log(8),  sdlog = 0.5),
  function(u) stats::qlnorm(u, meanlog = log(6),  sdlog = 0.5),
  function(u) stats::qnorm(u,  mean = 0,         sd = 1.0),
  function(u) stats::qnorm(u,  mean = 0,         sd = 1.0)
)

dist_trt <- list(
  function(u) stats::qlnorm(u, meanlog = log(10), sdlog = 0.5),
  function(u) stats::qlnorm(u, meanlog = log(8),  sdlog = 0.5),
  function(u) stats::qnorm(u,  mean = -0.3,       sd = 1.0),
  function(u) stats::qnorm(u,  mean = 0.5,        sd = 1.0)
)
```

### 2.3 Build `simdesign`

```{r}
design_pbo <- simdesign_gaussian_copula(
  dist        = dist_pbo,
  Sigma       = Sigma,
  structure   = "un",
  names_final = c("PFS_raw", "OS_extra", "BIOM_latent", "ORR_latent")
)

design_trt <- simdesign_gaussian_copula(
  dist        = dist_trt,
  Sigma       = Sigma,
  structure   = "un",
  names_final = c("PFS_raw", "OS_extra", "BIOM_latent", "ORR_latent")
)
```

## 3. Wrap `simdesign` into TrialSimulator `generator(n)`

Non-negotiable points of the TrialSimulator endpoint generator contract:

- The first argument name must be `n`
- The return value must be a length-`n` vector, or a `data.frame` with `n` rows
- For TTE endpoints: must include a `<name>_event` column
- For non-tte endpoints: column names must match those in `endpoint(name=...)`, and `readout` is required

Key wrapping logic in this example:

- First generate correlated variables via `simdata::simulate_data(design, n_obs = n)`
- Then construct:
  - `PFS = PFS_raw`
  - `OS = PFS_raw + OS_extra`, ensuring `OS >= PFS`
  - Initialize `*_event` to 1 (TrialSimulator applies censoring/truncation at database lock based on dropout/duration)
  - `ORR` as 0/1 from `ORR_latent > cutoff`
  - `BIOM` directly from `BIOM_latent`

```{r}
make_elliptical_endpoint_rng <- function(design, orr_cutoff) {
  function(n) {
    latent <- simdata::simulate_data(design, n_obs = n)

    pfs_raw  <- latent[["PFS_raw"]]
    os_extra <- latent[["OS_extra"]]

    PFS <- pfs_raw
    OS  <- pfs_raw + os_extra

    data.frame(
      PFS       = PFS,
      PFS_event = rep(1L, n),
      OS        = OS,
      OS_event  = rep(1L, n),
      ORR       = as.integer(latent[["ORR_latent"]] > orr_cutoff),
      BIOM      = latent[["BIOM_latent"]]
    )
  }
}

rng_pbo <- make_elliptical_endpoint_rng(
  design = design_pbo,
  orr_cutoff = stats::qnorm(0.6)
)

rng_trt <- make_elliptical_endpoint_rng(
  design = design_trt,
  orr_cutoff = stats::qnorm(0.4)
)

head(rng_pbo(n = 3))
head(rng_trt(n = 3))
```

## 4. Define endpoints and arms

We define 4 endpoints:

- `PFS`, `OS`: TTE
- `ORR`, `BIOM`: non-tte

And specify readout times for non-tte (`readout`):

- `ORR`: read out at month 6
- `BIOM`: available at baseline (0)

```{r}
ep_pbo <- endpoint(
  name      = c("PFS", "OS", "ORR", "BIOM"),
  type      = c("tte", "tte", "non-tte", "non-tte"),
  readout   = c(ORR = 6, BIOM = 0),
  generator = rng_pbo
)

ep_trt <- endpoint(
  name      = c("PFS", "OS", "ORR", "BIOM"),
  type      = c("tte", "tte", "non-tte", "non-tte"),
  readout   = c(ORR = 6, BIOM = 0),
  generator = rng_trt
)

arm_pbo <- arm(name = "placebo")
arm_pbo$add_endpoints(ep_pbo)

arm_trt <- arm(name = "treatment")
arm_trt$add_endpoints(ep_trt)
```

## 5. Define and Run the Trial

Here we define enrollment and dropout times (exponential) with two simple wrapper functions:

- `enroller_fn(n)`: generates each patient's enrollment waiting time (TrialSimulator accumulates this into calendar enrollment time)
- `dropout_fn(n)`: generates each patient's dropout duration measured from enrollment

```{r}
set.seed(202502)

enroller_fn <- function(n) stats::rexp(n, rate = log(2) / 4)
dropout_fn  <- function(n) stats::rexp(n, rate = log(2) / 40)

trial_obj <- trial(
  name       = "elliptical-copula-demo",
  n_patients = 400,
  duration   = 36,
  enroller   = enroller_fn,
  dropout    = dropout_fn,
  seed       = 202502,
  silent     = TRUE
)

trial_obj$add_arms(sample_ratio = c(1, 1), arm_pbo, arm_trt)

milestone_interim <- milestone(
  name   = "interim",
  when   = eventNumber(endpoint = "PFS", n = 100),
  action = doNothing
)

milestone_final <- milestone(
  name   = "final",
  when   = calendarTime(time = 36),
  action = doNothing
)

listener_obj <- listener()
listener_obj$add_milestones(milestone_interim, milestone_final)

controller_obj <- controller(trial_obj, listener_obj)
controller_obj$run(plot_event = FALSE)
```

## 6. Read Locked Data and Run Basic Checks

```{r}
locked_interim <- trial_obj$get_locked_data("interim")
locked_final   <- trial_obj$get_locked_data("final")

head(locked_interim)
head(locked_final)
```

### 6.1 Key Consistency Checks

1. `OS >= PFS` (guaranteed by the generation rule; should still hold after TrialSimulator censoring/truncation)
2. `cor(PFS, OS)` (should be clearly > 0)
3. ORR/BIOM differences between placebo vs treatment (should reflect your marginal choices)

```{r}
all(locked_final$OS >= locked_final$PFS, na.rm = TRUE)

with(locked_final, stats::cor(PFS, OS, use = "complete.obs"))

with(subset(locked_final, arm == "placebo"), mean(ORR, na.rm = TRUE))
with(subset(locked_final, arm == "treatment"), mean(ORR, na.rm = TRUE))

with(subset(locked_final, arm == "placebo"), mean(BIOM, na.rm = TRUE))
with(subset(locked_final, arm == "treatment"), mean(BIOM, na.rm = TRUE))
```

### 6.2 Censoring and Missingness Rates (Helpful for Interpreting TrialSimulator Output)

- For TTE: `*_event = 0` typically means the event has not been observed by database lock (censored due to follow-up cutoff or dropout)
- For non-tte: if database lock occurs before readout, or the patient has dropped out, the variable may be `NA`

```{r}
with(locked_final, tapply(PFS_event, arm, mean, na.rm = TRUE))
with(locked_final, tapply(OS_event,  arm, mean, na.rm = TRUE))

with(locked_final, tapply(is.na(ORR), arm, mean))
with(locked_final, tapply(is.na(BIOM), arm, mean))
```
